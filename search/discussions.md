---
layout: page
title: Discussions
nav_order: 99
parent: Search
---

# Discussions

## Architecture of the search mechanism. Damien Leroy and Geoffrey Huck. 2/05/2023

The requirement is the following: create a search mechanism across all items (title, subtitle, description and content which comes from crawling) which are visible by the user. A new search REST service serves as an API in front of the OpenSearch database which collects all the searchable info from the db, but it does not know about the permissions. So an initial solution would be to run the search on the OpenSearch db and then to ask the backend to filter among the results, those which are visible to the user. This has to be in an sane way, both in terms of "security" and "architecture".

### Solution 1: let the frontend do the 2 calls

Let the frontend call the search service without any form of authorization/authentication, get all ids that match, then call the backend to filter the results.

Main drawback: Security wise, this allow using the search service as an oracle to know some information about content we cannot see. We could even imagine writing a bot using search to guess exactly what is the title/content of invisible items (by trying every word)

### Solution 2: let the search service call the backend, using directly backend crendentials

Put the search service on the same "cookie path" as the backend so that the frontend uses the backend cookie when calling it. Then, let the search service use the cookie it receives to call the backend itself to filter the results before returning them.

Main drawback: This "leaks" the cookie which is supposed to be used for frontend-backend communication to a third party (the search service): Not great in terms of microservice architecture.

### Solution 3: let the search service call the backend, using as crendential a token generated by the backend

Require the frontend to first request a specific token to the backend, then call the search service with this token which then calls itself the backend using this token for authentication/authorization.

Main drawbacks:
- More complex workflow for the frontend
- Require a new authentication method for the backend
- Have a service calls another service in cascade is not great in terms of microservice architecture

### Solution 4: let the frontend do the 2 calls, encrypt non-public

In order to adress the security concern raised in solution 1, the search service could encrypt (using a shared symmetric key between the search service and the backend) results to be checked by the backend.

This require the backend to return as well the metadata that we need to display in the search results.

#### Improving speed of search

In order to improve the search speed, we could leave a split the output of the search service between the "public" content that we know are visible to the user and so can be visible (the search service can return the metadata), and the possibly-not-visible ids. Only the latter would be sent to the backend, making the backend request faster and allowing the frontend to display already the public results while the other ones are being fetched.

#### Remaining issues: encrypting the ids prevent the user to map the non-visible ids to a content but it still allows a dictionnary attack a described in soluton 1.

Some possibilities: (by Geoffrey)
1. The search service always return a fixed size encrypted result. But we would have to check that we cannot guess anything by looking at the encrypted result, and this would take more unnecessary bandwidth
2. The search service doesn't return the ids, but an encrypted token containing a search id. The backend would get the search result with the search id in a key/value database. It would require something more in the architecture, and add latency.
3. The search service sends the item ids along with an searchID to the backend, the searchID is returned to the customer. The backend filters the ids when the customer sends the searchID. This have the caveat of having a search->backend call.

Comments of these possibilities (by Damien):
1. This works only if the ids are returned (and not metadata). Actually, passing the public content directly and encrypting the non-public cannot work, even with possibility 1. You could still write a search request which returns public content with low score and so which would be returned only if your other search term does not match. In this way, you would still have a way to guess the content of non-visible elements.
2. This requires services to know each others and an addition store, so add a lot of operational complexity.
3. This requires search-specific store in backend, a way to communicate between service (with its specific authentication)

### Solution 5: let the frontend do the 2 calls, encrypted non-public and clear others

To avoid the caveat of solution 4, the search service may allow two types of request:
- search only across public content and include in the response the score and the metadata (title, subtitle, description, ...) so that the frontend can directly display the results without further request
- search only across non-public content, and return a fixed-sized response containing an encrypted list of ids+score (may require padding), the frontend would pass this response to the backend for the filtering out the non-visible ids and fetching the metadata.

The frontend would need to merge to two answers sorted by search score, and possibly drop some of the public results with the lowest scores.

Possible improvements:
- the 2 requests may be done in a single request to the search service
- a temporary user would not need to request the non-public content
- to speed up search: for some large groups of the platform, content may be tagged, in the search engine, if this group can see this content; then the backend could generate a token proving that the user belongs to these groups so the search results for this content could be returned with the non-encrypted content.

Remaining caveats:
- Let us consider the user wants 10 results so request 10 public ones, and 10 non-public ones... after getting the response from the backend, he gets no result from non-public ones. The user does not know if the request was empty or if none of the ids was visible to him... so how does he if he should ask the search service for "page 2" (possible page 2 of non-visible items have highest search score than the public content)? If we give the information that they are several pages, we give him the info that there were non-visible entries matching the search, coming back to the caveat of solution 4.
